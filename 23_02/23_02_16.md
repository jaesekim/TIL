# 230216 STACK3

### 부분집합의 합

```python
def f(i, k, s, t):
    """
    i: 원소
    k: 집합의 크기
    s: i-1까지 고려된 합
    t: 목표
    """
    global cnt
    if s > t:   # 고려한 원소의 합이 찾는 합 보다 큰 경우 함수 종료
        return  # 함수 호출을 적게 하기 위함
    
    if i == k:  # 끝까지 갔을 때
        if s == t:
            cnt += 1
        return
    else:
        f(i+1, k, s+A[i], t)  # A[i] 포함
        f(i+1, k, s, t)       # A[i] 미포함

A = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
N = len(A)
key = 1
cnt = 0
bit = [0] * N
f(0, N, 0, key)
print(cnt)  # 합이 key인 부분집합의 수
```

### 순열

**간단한 방법**

```python
def f(i, k):
    if i == k:  # 시작이 끝에 도달하면 함수 끝
        print(p)
    else:
        for j in range(i, k):  # i 조건을 하지 않으면 0 번째 인덱스랑 계속 같이 바꿔주게 돼서 안된다
            p[i], p[j] = p[j], p[i]  # 자기 자신과 바꾸는 경우의 수 그냥 고려하지말고 일단 해
            f(i+1, k)
            p[i], p[j] = p[j], p[i]

p = [1, 2, 3]
N = len(p)
f(i, N)
```

# 분할 정복 알고리즘

## 설계전략

- 분할: 해결할 문제를 여러 개의 작은 부분으로 나눈다.
- 정복: 나눈 작은 문제를 각각 해결한다.
- 통합: 필요하다면 해결된 해답을 모은다.

## 퀵 정렬

- 주어진 배열을 두 개로 분할하고 각각을 정렬
- 합병 정렬은 그냥 두 부분으로 나누는 반면 퀵 정렬은 분할할 때 기준 아이템 중심으로 이보다 작은 것은 왼편, 큰 것은 오른편에 위치시킨다
- 각 부분 정렬이 끝난 후 합병 정렬은 합병이라는 후처리가 필요하나 퀵 정렬은 필요하지 않는다.

### 수행과정

예제: [69, 10, 30, 2, 16, 8, 31, 22]

1. 원소의 개수가 8개 이므로 네 번째 자리에 있는 원소 2를 첫 번째 피봇으로 선택하고 퀵 정렬 시작
    
    `[69, 10, 30, 2, 16, 8, 31, 22]`  L == 69, R == 22
    
    1. L이 오른쪽으로 이동하면서 피봇보다 크거나 같은 원소를 찾고 R은 왼쪽으로 이동하면서 피봇보다 작은 원소를 찾는다
    2. L은 원소 69를 찾았지만 R은 피봇보다 작은 원소를 찾지 못한 채로 원소 69에서 L과 만나게 된다
    3. L, R이 만났으므로 원소 69를 피봇과 교환하여 피봇 원소 2의 위치를 확정한다
2. 피봇 2의 왼쪽 부분 집합은 공집합이므로 퀵정렬을 수행하지 않고 오른쪽 부분 집합에 대해 퀵 정렬 수행
    1. 오른쪽 부분 집합의 원소가 7개 이므로 가운데 있는 원소 16을 피봇으로 선택
        
        `2 [69, 10, 30, 16, 8, 31, 22]`   L == 69, R == 22, pivot == 16
        
    2. L이 찾은 30과 R이 찾은 8을 서로 교환한다
    3. 현재 위치에서 L, R의 작업을 반복한다
    4. L은 원소 69를 찾았지만 R 은 피봇보다 작은 원소를 찾지 못해 69에서 L과 R이 만난다 → 원소 69를 피봇과 교환하여 피봇 원소 16의 위치를 확정한다
        
        `2 [10 8 69 16 30 31 22]`
        
        `2 [10 8] 16 [69 30 31 22]`
        
3. 피봇 16의 왼쪽 부분 집합에서 원소 10을 피봇으로 선택해서 퀵 정렬 수행
    1. L의 원소 10과 R의 원소 8을 교환하는데 L의 원소가 피봇이므로 피봇 원소에 대한 자리 교환이 발생한 것이므로 교환한 자리를 피봇 원소 10의 위치로 확정
4. 피봇 10의 확정된 위치에서 왼쪽 부분집합은 원소가 한 개 이므로 퀵 정렬을 수행하지 않고 오른쪽 부분 집합은 공집합이므로 역시 퀵 정렬을 수행하지 않는다
    
    `2 [8] 10 16 [69 30 31 22]`
    

…… 반복

**참고 코드**
``` python
def quickSort(a, begin, end):
		if begin < end:
				p = partition(a, begin, end)  # p 위치를 기준으로 오른쪽, 왼쪽 구분
				quickSort(a, begin, p-1)
				quickSort(a, p+1, end)
```
``` python
def partition(a, begin, end):
    pivot = (begin + end) // 2
    L = begin
    R = end
    while L < R:
        while L < R and a[L] < a[pivot]:
            L += 1
        while L < R and a[R] >= a[pivot]:
            R -= 1
        if L < R:
            if L == pivot:
                pivot = R
                a[L], a[R] = a[R], a[L]
    a[pivot], a[R] = a[R], a[pivot]
    return R
```