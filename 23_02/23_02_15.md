# 23.02.15. STACK2

## 계산기1

- 문자열로 된 계산식이 주어질 때, 스택을 이용하여 이 계산식의 값을 계산할 수 있다.
- 문자열 수식 계산의 일반적 방법
    - step1. 중위 표기법의 수식을 후위 표기법으로 변경한다(stack 이용).
    - step2. 후위 표기법의 수식을 스택을 이용하여 계산한다.
    
    ```
    중위 표기법: 연산자를 피연산자의 가운데 표기하는 방법 -> a + b
    후위 표기법: 연산자를 피연산자 뒤에 표기하는 방법 -> ab+
    ```
    
- STEP1: 중위 표기식의 후위표기식 변환 방법1
    - 수식의 각 연산자에 대해서 우선순위에 따라 괄호를 사용하여 다시 표현한다.
    - 각 연산자를 그에 대응하는 오른쪽 괄호의 뒤로 이동
    - 괄호를 제거
- STEP2: 후위 표기법의 수식을 스택을 이용해서 계산
    - 피연산자를 만나면 스택에 `push`
    - 연산자를 만나면 필요한 만큼 피연산자를 스택에서 pop하여 연산하고 연산 결과를 다시 스택에 push 한다
    - 수식이 끝나면 마지막으로 스택을 pop하여 출력

# 백트래킹

## 백트래킹

- 해를 찾는 도중에 막히면, 즉 해가 아니면 되돌아가서 다시 해를 찾는 기법
- 백트래킹 기법은 최적화(optimization) 문제와 결정(decision) 문제를 해결할 수 있다.
- 결정 문제: 문제의 조건을 만족하는 해가 존재하는지 여부를 yes or no 답하는 문제
    - 미로 찾기
    - n-Queen
    - Map coloring
    - 부분집합 sum

### 백트래킹과 깊이우선탐색의 차이

- 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도 횟수를 줄인다.
- 깊이 우선 탐새이 모든 경로를 추적하는데 비해 백트래킹은 불필요한 경로를 조기 차단
- 깊이 우선 탐색을 가하기에는 경우의 수가 너무 많다. N!가지 경우의 수를 가진 문제에서 DFS 사용하면 처리 불가
- 백트래킹 알고리즘을 적용하면 일반적으로 경우의 수가 줄어들지만 그래도 **최악의 경우**에는 여전히 지수함수 시간을 필요하므로 처리 불가능하다. (정답과 가장 먼 경로부터 찾는 경우)

**모든 후보를 검사하지 않는다!**

### 백트래킹 절차

1. 상태 공간 트리의 깊이 우선 검색 실시
2. 각 노드가 유망한지 점검
3. 노드가 유망하지 않다면 그 노드의 부모 노드로 돌아가서 검색을 계속한다.

### 일반 백트래킹 알고리즘

n-queen pseudo code

```
def checknode(v):  # node
		if promising(v):  # node가 유망하다면
				if ther is a solutinon at v:  # 찾는 최종 해라면
						write the solution
				else:
						for u in each child of v:  # v의 가지들에 대해서 확인
								checknode(u)
```

### 부분집합 구하기

- 어떤 집합의 공집합과 자기자신을 포함한 모든 부분집합을 powerset이라고 하며 구하고자하는 어떤 집합의 원소 개수가 n일 경우 부분집합의 개수는 2^n개이다.
- 백트래킹 기법으로 powerset 구하기
    - n개의 원소가 들어있는 집합의 2^n개의 부분집합을 만들 때는 True 또는 False  값을 가지는 항목들로 구성된 n개의 배열을 만드는 방법을 이용
    - 여기서 배열의 i번째 항목은 i번째의 원소가 부분집합의 값인지 아닌지를 나타내는 값

```
def backtrackdef backtrack(a, k, input):
    global MAXCANDIDATES
    c = [0] * MAXCANDIDATES
    
    if k == input:
        process_solution(a, k)  # 답이면 원하는 작업을 한다
    else:
        k += 1
        ncandidates = construct_candidates(a, k, input, c)
        for i in range(ncandidates):
            a[k] = c[i]
            backtrack(a, k, input)
```

```
def construct_candidates(a, k, input, c):
    c[0] = True
    c[1] = False
    return 2

MAXCANDIDATES = 2
NMAX = 4
a = [0] * NMAX
backtrack(a, 0, 3)
```

→ 순열을 구하는 함수와 같은 구조

---

# 후위 표현식

- 중위 표현식 → 일반적으로 알고 있는 산술 방식
- 후위 표현식
    - WHY? 컴퓨터가 이해하는 산술 방식으로 변경하기 위한 목적
    - 속도 향상
    - 연산자가 피연산자(숫자) 뒤에 온다.
    - STACK 내부와 외부의 연산자 우선순위
    - 
    
    | 토큰 | isp(stack top, 내부) 비교대상 | icp (자신, 외부) |
    | --- | --- | --- |
    | ) | - | - |
    | *, /  | 2 | 2 |
    | +, - | 1 | 1 |
    | ( | 0 | 3 |
    1. 중위 표현식으로 된 식을 순회할 것
        
        순회되는 원소를 토큰화한다.
        
    2. 토큰을 담을 빈 스택을 생성한다.
    3. 토큰이 연산자인 경우
        1. 스택이 비어있을 경우에 스택에 `push`
            - 스택으로 들어올 토큰이 `(` 이면 스택에 `push`
        2. 스택에 들어올 토큰 icp > 스택 `top` 에 있는 토큰의 isp(비교대상)
            - `push`
        3. 스택에 들어올 토큰 icp ≤ 스택 `top` 에 있는 토큰의 isp(비교대상)
            - `b` 단계가 만족할 때까지 스택에서 `pop()` 하고 **결과**에 `push`
            - `b` 단계가 만족하면 스택으로 들어오는 토큰을 **스택**에 `push`
        4. 스택에 들어올 토큰이 `)` 
            - `(` 를 만날 때까지 스택에서 `pop` 한 토큰을 결과에 `push`
            - `(` 는 결과에 `**push` 하지 않고** `pop` 만 한다.
        5. 순회를 마치면 스택이 비어있을 때까지 스택에서 `pop` 한 토큰을 결과에 `push` 한다.