# 23.02.14. STACK

## 재귀 호출

- 자기 자신을 호출하여 순환 수행되는 것
- 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀호출방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성

**ex1) 팩토리얼**

```
fac(4): 4 x fac(3) → fac(3) 호출

fac(3): 3 x fac(2) → fac(2) 호출

fac(2): 2 x fac(1) - > fac(1) 호출

fac(1): return 1

fac(2) → 2 x 1

fac(3) → 3 x 2 x 1

fac(4) → 4 x 3 x 2 x 1
```

**ex2) 피보나치**

`f0 = 0, f1 = 1`

## M**emoization**

- 피보나치 수를 구하는 함수를 재귀로 구현한 알고리즘은 엄청난 중복 호출이 존재한다는 단점이 있다.
- 메모이제이션은 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 해서 전체적인 실행 속도를 빠르게 하는 기술.
- 피보나치 수를 구하는 알고리즘에서 fibo(n)의 값을 계산하자마자 저장하면 실행시간을 `O(n)`으로 줄일 수 있다.

```python
def fibo(n):
		global momo
		if n >= 2 and memo[n] == 0:
				memo[n] = (fibo(n-1) + fibo(n-2))
		return memo(n)
```

## DP(Dynamic Programming)

- 동적 계획 알고리즘은 그리디 알고리즘과 같이 **최적화 문제**를 해결하는 알고리즘이다
- 먼저 입력 크기가 작은 부분 문제들을 해결한 후에 이 해를 이용하여 주어진 입력의 문제를 해결하는 알고리즘.
- 피보나치 DP
    - fibo(n) = fibo(n - 1) + fibo(n - 2)

```python
def fibo_dp(n):
		f = [0] * (n + 1)
		f[0] = 0
		f[1] = 1
		for i in range(2, n + 1):
				f[i] = f[i - 1] + f[i - 2]
		return f[n]
```

- memoization을 재귀적 구조에 사용하는 것보다 DP를 구현한 것이 성능 면에서 보다 효율적
- 재귀적 구조는 내부 시스템 호출 스택을 사용하는 오버헤드가 발생하기 때문이다.

## DFS(깊이우선탐색)

비선형구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요

- DFS: 깊이 우선 탐색
- BFS: 너비 우선 탐색

### DFS

- 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더이상 갈 곳이 없게 되면 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회방법
- 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출 구조의 `스택` 사용

### DFS 알고리즘

1. 시작 정점 v를 결정하여 반문한다
2. 정점 v에 인접한 정점 중에서
    1. 방문하지 않은 정점 w가 있으면 정점 v를 스택에 `push` 하고 정점 w를 방문한다. 그리고 w를 v로하여 2를 반복
    2. 방문하지 않은 정점이 없으면 탐색의 방향을 바꾸기 위해서 스택을 `pop` 하여 받은 가장 마지막 방문 정점을 v로하여 다시 2를 반복한다.
3. 스택이 공백이 될 때까지 2를 반복한다.

***pseudo code***
```
vistited[], stack[] 초기화
DFS(v)
		시작점 v 방문
		visited[v] <- True:
		while
		{
				if (v의 인접 정점 중 방문 안 한 정점 w가 있으면)
						push(v);
						v <- w  # w에 방문
						visited[w] <- True
				else:
						if 스택이 비어있지 않으면:
								v <- pop(stack)
								# 시작 시점을 재설정 하는 목적
						else:
								break
		}
```