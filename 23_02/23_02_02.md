# 23.02.02. 정렬

# 정렬

## 카운팅 정렬

**항목들의 순서를 결정하기 위해 집합에 각 항목이 며 개씩 있는지 세는 작업을 하여 선형 시간에 정렬하는 효율적인 알고리즘**

- 제한 사항
    - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능. 각 항목의 발생 횟수를 기록하기 위해 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문이다
    - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다
- 시간 복잡도
    
    O(n + k): n은 리스트 길이, k는 정수의 최대값
    
    ```python
    A = [7, 0, 9, 4, 5, 1, 3, 9]
    
    cnt = [0] * 10
    for x in A:
    cnt[x] += 1
    ```
    

**1단계**

data에서 각 항목들의 발생 회수를 세고 정수 항목들로 직접 인덱스 되는 카운트 배열 counts에 저장한다

```python
data = [0, 4, 1, 3, 1, 2, 4, 1]  # 정수 범위 [0, 4]
counts = [0, 0, 0, 0, 0]  # 0 부터 4까지 인덱스와 동일하게 맞춰줌
->
counts = [1, 3, 1, 1, 2]  # 0 1개, 1 3개, ... , 4 2개
"""
counts[i] == i의 발생 횟수
```

**2단계**

정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 원소 조정

```python
counts = [1, 3, 1, 1, 2]

counts = [1, 4, 5, 6, 8]  
# counts의 앞의 것과 더해서 누적값을 다시 저장
```

**3단계**

```python
data = [0, 4, 1, 3, 1, 2, 4, 1]

counts = [1, 4, 5, 6, 8]
->
counts = [1, 3, 5, 6, 8]
tmep = [_, _, _, _, _, _, _, _]
"""
1. 맨 뒤의 데이터의 수 확인
2. 1 이니까 counts의 인덱스 1을 확인
3. counts[1] == 4 이므로 1이라는 숫자는 앞에 최소 3개의 숫자가 존재함을
의미
4. temp 빈 리스트 4번째 인덱스에 1을 삽입(1을 포함한 숫자 최소 네 개 존재)
5. counts의 1번 인덱스 값을 1 감소
6. data[-2]의 값으로 위 과정 반복
"""
```

| 알고리즘 | 평균 수행 시간 | 최악 수행시간 |  알고리즘 기법 |  비고 |
| --- | --- | --- | --- | --- |
| 버블 정렬 |  O(n^2) | O(n^2) | 비교와 교환 | 코딩이 가장 손쉽다 |
| 카운팅 정렬 | O(n + k) | O(n + k) | 비교환 방식 |  n이 비교적 적을 때 |
|  선택 정렬 |  O(n^2) | O(n^2) | 비교와 교환 |  교환 횟수가 버블, 삽입보다 적다 |
| 퀵정렬 |  O(n*logn) | O(n^2) | 분할 정복 |  최악의 경우는 O(n^2)이지만 평균적으로 가장 빠르다 |
| 삽입 정렬 |  O(n^2) | O(n^2) | 비교와 교환 |  n의 개수가 적을 때 효과적 |
| 병합 정렬 | O(n*logn) | O(n*logn) | 분할 정복 | 연결리스트의 경우 효율적 |

# 완전 검색

- 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
- Brute-force 혹은 generate-and-test 기법
- 모든 경우의 수를 테스트한 후 최종 해법을 도출
- 일반적으로 경우의 수가 상대적으로 적을 때 유용
- 수행 속도는 느리지만 해답을 찾아내지 못할 확률은 적다
- 일단 완전 검색으로 접근하고 나중에 성능 개선으로 다른 알고리즘으로 확인

## 순열

1, 2, 3을 포함하는 모든 순열

```python
for p in range(1, 4):
		for q in range(1, 4):
				if q != p:
						for r in range(1, 4):
								if r != p and r != q:
										print(p, q, r)
```

## Greedy 알고리즘

- 최적해를 구하는 데 사용되는 근시안적 방법
- 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달
- 각 선택의 시점에서 이뤄지는 결정은 local에서는 최적. 하지만 최종적으로 최적이라는 보장은 없다.
- 일반적으로 머리 속에 떠오르는 생각을 검증 없이 바로 구현하면 greedy 접근이 된다.

**동작 과정**

- 해 선택: 현재 상태에서 부분 문제의 최적 해를 구한 뒤 이를 부분 해 집합에 추가
- 실행 가능성 검사: 새로운 부분 해 집합이 실행 가능한지 확인. 곧, 문제의 제약 조건을 위반하지 않는지 검사
- 해 검사: 새로운 부분 해 집합이 문제의 해가 되는지 확인. 안 끝났으면 다시 반복.

## Baby-gin Game

```python
"""
444345 입력
"""
counts = [0, 0, 0, 1, 4, 1, 0, 0, 0, 0]
# run 조사 후 run 데이터 완전 삭제
counts = [0, 0, 0, 0, 3, 0, 0, 0, 0, 0]
"""
run 부터 하면 안되는 경우가 생긴다
333456 일 때
345를 run으로 인지했을 때 triplet이 성립하지 않게 된다.
"""
```