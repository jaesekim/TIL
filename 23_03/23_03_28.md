# 23.03.28. 완전 검색 & 그리디

# 부분집합

- 다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분 집합을 찾는 것이다
- N개의 원소를 포함한 집합
- 단순하게 모든 부분 집합 생성하는 방법
    
    4개 원소를 포함한 집합에 대한 power set 구하기
    
    ```
    for 문 네 개 중첩
    ```
    
- 비트연산자 활용
    
    ```python
    # psudo code
    
    arr = [3, 6, 7, 1, 5, 4]
    n = len(arr)
    
    for i in range(0, (1 << n)):  # 1 << n: 부분집합의 개수
    		for j in range(0, n):
    				# i의 j번째 비트가 1이면 j번째 원소 출력
    				if i & (1 << j):
    						print(arr[j], end='')
    		print()
    ```
    
- 재귀함수로 부분집합 구하기
    
    ```python
    # make subsets using recursive
    # pseudo code
    
    def mk_subset(i, k):
        if i == k:
            pass
        else:
            bit[i] = 0
            mk_subset(i + 1, k)
            bit[i] = 1
            mk_subset(i + 1, k)
    
    A = [7, 2, 5, 3, 4]
    N = len(A)
    bit = [0] * N
    # bit[i] A[i] 원소가 부분집합에 포함되는지 표시
    ```
    

# Combination

재귀적 표현: nCr = n-1Cr-1 + n-1Cr

- 재귀 호출 조합 알고리즘
    
    ```
    tr = []  : r개의 크기 배열, 조합이 임시 저장될 배열
    an = []  : n개 원소를 가지고 있는 배열
    comb(n, r):
    		if r == 0: print_arr()
    		elif n < r: return
    		else:
    				tr[r - 1] = an[n - 1]  맨 뒷 칸 부터 채우는 알고리즘
    				comb(n - 1, r - 1)
    				comb(n - 1, r)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/93e8519c-65c2-46f5-9498-d1425512046b/Untitled.png)
    
- 참고: r이 고정인 경우 + for 문 중첩이 많이 안 될 때
    
    ```python
    N = 10
    cnt = 0
    for i in range(N-2):
        for j in range(i+1, N-1):
            for k in range(j+1, N):
                print(i, j, k)
                cnt += 1
    print('total: ', cnt)
    
    ```
    

# 그리디 알고리즘

- 최적해를 구하는 데 사용되는 근시안적인 방법
- 일반적으로 머리속에 떠오르는 생각을 검증없이 바로 구현하면 greedy 접근이 된다
- 여러 경우 하나를 선택 할 때 마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
- 각 선택 시점에서 이뤄지는 결정은 지역적으로는 최적이지만 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, **그것이 최적이라는 보장은 없다.**
    
    → local optimization ≠ global optimization
    
- **일단 한 번 선택된 것은 번복하지 않는다.** 이런 특성 때문에 대부분의 탐욕 알고리즘들은 단순하며 제한적인 문제들에 적용된다.
- 최적화 문제란 가능한 해들 중에서 가장 좋은(최대 또는 최소) 해를 찾는 문제이다.

## 탐욕 알고리즘의 동작 과정

1. 해 선택: 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합에 추가한다.
2. 실행 가능성 검사: 새로운 부분 해 집합이 실행 가능한지를 확인한다. 곧, 문제의 제약 조건을 위반하지 않는지를 검사한다.
3. 해 검사: 새로운 부분 해 집합이 문제의 해가 되는지 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 1의 해 선택부터 다시 시작한다.

### 그리디 알고리즘을 적용한 거스름돈 줄이기

1. 해 선택: 멀리 볼 것도 없이 가장 좋은 해 선택한다. 단위가 큰 동전으로만 거스름돈을 만들면 동전의 개수가 줄어드니까 현재 고를 수 있는 가장 단위가 큰 동전을 하나 골라 거스름돈에 추가
2. 실행 가능성 검사: 거스름돈이 손님에게 내 드려야 할 액수를 초과하는 지 확인하고 초과한다면 마지막에 추가한 동전을 거스름돈에서 빼고 1로 돌아가서 현재보다 한 단계 작은 단위의 동전을 추가한다.
3. 해 검사: 거스름돈 문제의 해는 당연히 거스름돈이 손님에게 내 드려야 하는 액수와 일치하는 셈이다. 더 드려도 덜 드려도 안되기 때문에 거스름돈을 확인해서 액수가 모자라다면 다시 1로 돌아가서 거스름돈에 추가할 동전을 고른다.